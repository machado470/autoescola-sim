// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum ExamStatus {
  DRAFT
  IN_PROGRESS
  FINISHED
  CANCELLED
}

model Question {
  id         String     @id @default(cuid())
  statement  String
  difficulty Difficulty
  imageUrl   String?
  tags       String[]
  choices    Choice[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  // back-relation obrigatório para StudentAnswer.question
  answers StudentAnswer[] @relation("QuestionAnswers")

  @@index([difficulty])
}

model Choice {
  id         String   @id @default(cuid())
  text       String
  isCorrect  Boolean  @default(false)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId String

  // back-relation para StudentAnswer.choice
  answers StudentAnswer[] @relation("ChoiceAnswers")

  @@index([questionId])
}

model ExamSession {
  id             String     @id @default(cuid())
  status         ExamStatus @default(DRAFT)
  startedAt      DateTime?
  finishedAt     DateTime?
  totalQuestions Int        @default(0)
  correctAnswers Int        @default(0)
  score          Float? // percentual (0–100) ou pontos
  metadata       Json? // livre: device, ip, etc.

  answers   StudentAnswer[]
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([status])
  @@index([createdAt])
}

model StudentAnswer {
  id String @id @default(cuid())

  examSession   ExamSession @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  examSessionId String

  // relação Question <-> StudentAnswer (1:N)
  question   Question @relation("QuestionAnswers", fields: [questionId], references: [id], onDelete: Cascade)
  questionId String

  // relação Choice <-> StudentAnswer (1:N, opcional)
  choice   Choice? @relation("ChoiceAnswers", fields: [choiceId], references: [id], onDelete: SetNull)
  choiceId String?

  isCorrect  Boolean  @default(false)
  answeredAt DateTime @default(now())

  // Evita duas respostas para a MESMA questão na MESMA sessão
  @@unique([examSessionId, questionId])
  @@index([examSessionId])
  @@index([questionId])
  @@index([choiceId])
}
